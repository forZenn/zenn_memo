---
title: "How to migrate from javascript to typescript on react"
emoji: "ğŸ‘Œ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ['typescript', 'react', 'nodejs', 'javascript']
published: true
---

## Get Started

I talk about migrating from javascript to typescrit on react.

There are three ways to typescript.

Both methods require the typescript library to be installed.

### directly to migrate to typescript

Significantly change the project by changing all file extensions from js, mjs, jsx to ts.

Advantages

1. The method is orthodox.

Disadvantages

1. In the operational phase, it is difficult to take this approach.

### using allowJS

Add allowjs key in tsconfig.json

```json:tsconfig.json
{
  "compilerOptions": {
    "target": "es5",
    "baseUrl": "src",
    "lib": [
        ...
    ],
    "allowJs": true,
    ...
  }
}
```

Advantages

1. Can use both js and ts.

Disadvantages

1. It is difficult to isolate problems when they occur.

### using @ts-check

If you write a comment in jsdoc format and @ts-check at the top of the file, vscode will show type hints and use them.

jsdocå½¢å¼ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ›¸ã„ã¦ã€ts-checkã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€ç•ªä¸Šã«æ›¸ãã¨vscodeãŒå‹ãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤ºã—ã¦ãã‚Œã‚‹ã®ã§ãã‚Œã‚’ä½¿ã†ã€‚

In addition, using ts-check, javascript can be handled as safely as typescript because the syntax checks are the same as those of typescript with a few exceptions.

ã¾ãŸts-checkã‚’ä½¿ã†ã¨ã€typescriptã¨ä¸€éƒ¨ã‚’é™¤ã„ã¦åŒã˜æ§‹æ–‡ãƒã‚§ãƒƒã‚¯ãŒå…¥ã‚‹ãŸã‚ã€typescriptã¨åŒã˜ãã‚‰ã„å®‰å…¨ã«javascriptã¨æ‰±ã†äº‹ãŒã§ãã‚‹ã€‚

You can also check linter like eslint, pretieer as typescript, and it will be displayed as an error on vscode.

vscodeã§expressã‚¨ãƒ©ãƒ¼ã®è¡¨ç¤º

In fact, since microsoft is also proposing to include type hints in javascript and is close to that approach, it is likely to work even if typescript becomes legacy.

å®Ÿã¯microsoftã‚‚javascriptã«å‹ãƒ’ãƒ³ãƒˆã‚’å…¥ã‚Œã‚ˆã†ã¨ã€ææ¡ˆã—ã¦ã„ã¦ãã®ã‚„ã‚Šæ–¹ã«è¿‘ã„ãŸã‚ã€typescriptãŒãƒ¬ã‚¬ã‚·ãƒ¼ã«ãªã£ã¦ã‚‚é€šç”¨ã™ã‚‹å¯èƒ½æ€§ãŒé«˜ã„ã€‚

[micrsoft proposal](https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/)

```js:example.js
// @ts-check
// Write @ts-check on the first line of the file.

// example variable
/** @type {number} */
let count = 0;

// if you do not know type or convert dificulty to typescript,
// use @ts-ignore, this comment ignore typescript check.


// @ts-ignore


```

```js:components/.js
// @ts-check
// example react components

// interface

```

```js:pages/purchase.js
// @ts-check
// example next

/**
 * @description example next pages
 * @param {{csrfToken: string}} _ 
 * @returns {JSX.Element}
 */
export default function PurchasePage({csrfToken}) {
    ...

   /**
   * @description submit function using react hook form.
   * @param {{merchandise1: string}} data
   * @param {React.BaseSyntheticEvent} event
   */
  const submitForm = (data, event) => {

    /** @type {HTMLFormElement} */
    const form = document.querySelector('#post_form');

    /** @type {HTMLButtonElement} */
    const form_button = form.querySelector('button');

    /** @type {HTMLInputElement} */
    const email = document.querySelector('input[name="merchandise1"]');

    email.value = getValues('merchandise1');

    // fire click event. and post.
    form_button.click()
  }
  ...
  return (
      <div>
      ...
      </div>
  )
}

/**
 * @description example next + customserver(express)
 * @param {{req: import('express').Request; res: import('express').Response}} _ 
 * @returns {Promise<{props: {csrfToken: string;};}>}
 */
export async function getServerSideProps({ req, res }) {

  const csrfToken = req.csrfToken();
  return {
    props: {
      csrfToken
    },
  }
}

```

Advantages

1. Typescript conversion can proceed in parallel with development.
2. No need to include tools for building ts.
3. It is only a comment, so it does not interfere with the build of react and next.

DisAdvantages

1. Sometimes it is necessary to read the source code of the nodejs library to be used in order to write a jsdoc with the correct type.It will be necessary to read the source code of the nodejs library to be used in order to write a jsdoc with the correct type.
2. Development speed is slower than javascript alone and need to know nodejs configuration and specifications
3. Javascript can get caught up in typescript bugs. Sometimes you need to check for issues on github.

(example3) [nodejs package subpath pattern](https://github.com/microsoft/TypeScript/issues/44848)

Because of this bug, an error is displayed on vscode even though the path to the project library passes.

[subpath pattern](https://nodejs.org/api/packages.html)

In this article, we will explain how to directly typescript the javascript in 1.

ä»Šå›ã¯1ã®javascript

## Prepation

### editor

Since vscode works well with typescript intellisense and also with lint
You should use vscode. I don't recommend vim very much. vscode with a vim plugin and be patient.

vscodeãŒtypescriptã®ã‚¤ãƒ³ãƒ†ãƒªã‚»ãƒ³ã‚¹ã€ã¾ãŸlintã¨ç›¸æ€§ãŒã„ã„ã®ã§ã€ \
*vscodeã‚’ä½¿ã†ã¹ã*ã€‚ vimã¯ã¨ã¦ã‚‚ã˜ã‚ƒãªã„ãŒã€ãŠã™ã™ã‚ã§ããªã„ã€‚vscodeã«vimã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’å…¥ã‚Œã¦æˆ‘æ…¢ã—ã¦ãã ã•ã„ã€‚

### 

ä½¿ã†ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã‚‹æ‹¡å¼µã‚’ä¸¦ã¹ã¦ãŠãã€‚
ã“ã‚Œã‚‰ã‚’vscodeã®æ‹¡å¼µã¨ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ãŠãã“ã¨ã€‚

The extensions that are recommended to be used are listed below.
These should be installed as extensions to vscode.

- dsznajder.es7-react-js-snippets
- ms-vscode.vscode-typescript-next
- dbaeumer.vscode-eslint
- esbenp.prettier-vscode

With vimmer, install the following as well. Note that this extension has some vim commands that aren't available yet. (Commands such as :m,:g)

vimmerãªã‚‰ä¸‹è¨˜ã®ã‚‚ã®ã‚‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã€‚ãªãŠã€ã“ã®æ‹¡å¼µã«ã¯ã¾ã ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ãªã„vimã‚³ãƒãƒ³ãƒ‰ãŒã‚ã‚‹ã®ã§æ³¨æ„ã™ã‚‹ã“ã¨ã€‚(:m, :g ãªã©ã®ã‚³ãƒãƒ³ãƒ‰ã¨ã‹ã€‚)

- vscodevim.vim

## addt ypescript library 

Addã€€typescript, @types/node,@types/react,@types/reactRouter,@types/reactDom,@types/jest,@types/materialUi, etc. (At this point, do not add lint libraries for simplicity, as they cause errors during build.)

typescript,react,reactRouter,reactDom,jest,materialUiãªã©ã®@typesè¿½åŠ (ã“ã®æ™‚ç‚¹ã§ã¯ç°¡å˜ã®ãŸã‚ã€lintç³»ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’è¿½åŠ ã—ãªã„ã€‚buildæ™‚ã«ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ãŸã‚ã€‚)

```shell
# Look up necessary @types, etc.
yarn add --dev typescript @types/node-sass @types/node @types/jest @material-ui/types @types/react @types/react-dom

# npm install
npm install --seve-dev typescript @types/node-sass @types/node @types/jest @material-ui/types @types/react @types/react-dom
```

## generate tsconfig.json

Create another project to create a configuration file.
This method is recommended because the configuration of tsconfig.js is difficult to write thoughtfully and is a source of syntax errors.

è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆã®ãŸã‚ã€ä»–ã«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã€‚ \
tsconfig.jsã®è¨­å®šã¯è€ƒãˆã¦æ›¸ãã®ã¯é›£ã—ãã€ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚¨ãƒ©ãƒ¼ã®å…ƒã«ãªã‚‹ã®ã§ã€ã“ã®ã‚„ã‚Šæ–¹æ¨å¥¨ã€‚

```shell
create-react-app <dummy_project> --template typescript
```

Copy the generated tsconfig.json and insert it into the new project you want to typescript.

ç”Ÿæˆã•ã‚ŒãŸtsconfig.jsonã‚’ã‚³ãƒ”ãƒ¼ã—ã¦
æ–°ã—ãtypescriptåŒ–ã—ãŸã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«çªã£è¾¼ã‚“ã§ãŠãã€‚

## Replace jsconfig.js with tsconfig.js

If the jsconfig.json file was used in the project that you want to typescript,
move the settings to tsconfig.js because typescript cannot use jsconfig.js.

ã‚‚ã—ã€typescriptåŒ–ã—ãŸã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§jsconfig.jsonãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ã£ã¦ã„ãŸå ´åˆã€ \
typescriptã§ã¯jsconfig.jsã‚’ä½¿ãˆãªã„ãŸã‚ã€è¨­å®šã‚’tsconfig.jsã«ç§»ã™ã€‚

```json:jsonfig.json
{
  "compilerOptions": {
    "baseUrl": "src",
    "paths": {
      "*": ["src/*"]
    }
  }
}
```

```json:tsconfig.json
{
  "compilerOptions": {
    "target": "es5",
    "baseUrl": "src",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}
```

Just put the setting in the corresponding key and that's it.
jsconfig.json must be deleted. If you leave it, the build will fail.
(If you really want to keep it, you can change the extension to something like .txt, but it's not necessary if you're using git.)

å¯¾å¿œã™ã‚‹ã‚­ãƒ¼ã«è¨­å®šã‚’å…¥ã‚ŒãŸã‚‰ãã‚Œã§è‰¯ã„ã€‚ \
jsconfig.jsonã¯å‰Šé™¤ã—ã¦ãŠãã“ã¨ã€‚æ®‹ã—ã¦ãŠãã¨ãƒ“ãƒ«ãƒ‰ã«å¤±æ•—ã™ã‚‹ã€‚ \
(ã©ã†ã—ã¦ã‚‚æ®‹ã—ãŸã„ãªã‚‰.txtã¿ãŸã„ã«æ‹¡å¼µå­å¤‰ãˆã‚Œã°ã„ã„ã‘ã©ã€gitä½¿ã£ã¦ã‚‹ãªã‚‰å¿…è¦ãªã„ã€‚)

You want to check if there are any problems with tsconfig.json, etc. here, so please build it.
If it works, no error will occur.

ã“ã“ã§tsconfig.jsonãªã©ã«å•é¡Œç„¡ã„ã‹ãƒã‚§ãƒƒã‚¯ã—ãŸã„ã®ã§ãƒ“ãƒ«ãƒ‰ã—ã¦ã¿ã¦ãã ã•ã„ \
ã†ã¾ãã„ã£ã¦ã„ã‚Œã°ã‚¨ãƒ©ãƒ¼ã¯ç™ºç”Ÿã—ã¾ã›ã‚“ã€‚

```shell
yarn build
```

## Fix import of each js file

You eliminate the .js  extensions for the from part as shown below.

Using the editor's replace function makes it easier, but be aware that it is easy to get other strings involved.
You check the git diff to make sure you have replaced it correctly.

ä¸‹è¨˜ã®ã‚ˆã†ã«froméƒ¨åˆ†ãŒ.jsã¨jsã®æ‹¡å¼µå­ã«ãªã£ã¦ã„ã‚‹ã‚‚ã®ã®æ‹¡å¼µå­ã‚’ç„¡ãã™ã€‚
javascriptã‹ã‚‰typescriptã ã‹ã‚‰å½“ç„¶ã€‚

ã‚¨ãƒ‡ã‚£ã‚¿ã®ç½®æ›æ©Ÿèƒ½ã‚’ä½¿ã†ã¨æ¥½ã«ãªã‚‹ãŒã€ä»–ã®æ–‡å­—åˆ—ã‚’å·»ãè¾¼ã¿ã‚„ã™ã„ã®ã§æ³¨æ„ã€‚
gitã®å·®åˆ†ã‚’è¦‹ã¦æ­£ã—ãç½®æ›ã§ãã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹ã“ã¨ã€‚

```js
// import Hello from 'components/hello.js'
import Hello from 'components/hello'
```

## Change the file extension to typescript

You change .js to .ts extension.
This process can be written in bash, but pwsh is easier to write and more secure script.
pwsh is recommended. linux and mac users should install and use pwsh.

The following is how to write the script assuming that the js files are under the src folder.
The same way to write .jsx to .tsx.

.jsã‚’.tsã«å¤‰æ›´ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Štypescriptã«å¤‰æ›´ã—ã¾ã™ã€‚
ã“ã®å‡¦ç†ã¯bashã§ã‚‚æ›¸ã‘ã‚‹ãŒã€pwshã®ã»ã†ãŒæ›¸ãã‚„ã™ãå®‰å…¨ãªã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ãªã‚‹ã®ã§
pwshæ¨å¥¨ã€‚linux, macã®äººã¯pwshã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ä½¿ã£ã¦ã¿ã‚ˆã†ã€‚

ä¸‹è¨˜ã¯srcãƒ•ã‚©ãƒ«ãƒ€ä»¥ä¸‹ã«jsãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹ã¨æƒ³å®šã—ãŸæ™‚ã®æ›¸ãæ–¹ã€‚
jsx->tsxã‚‚åŒã˜è¦é ˜ã§æ›¸ãã€‚

```powershell
#  -WhatIf to check if the assumed file is renamed
# -WhatIfã«ã‚ˆã‚Šã€æƒ³å®šã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒªãƒãƒ¼ãƒ ã•ã‚Œã‚‹ã‹ã©ã†ã‹ç¢ºèª
Get-ChildItem -Recurse src/ |
  Where-Object {$_.Name -match ".js$"} | 
  Rename-Item -NewName { $_ -replace "\.js$", ".ts" } -WhatIf

# Change file extension.
# ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã‚’å¤‰æ›´ã€‚
Get-ChildItem -Recurse src/ |
  Where-Object {$_.Name -match ".js$"} | 
  Rename-Item -NewName { $_ -replace "\.js$", ".ts" }
```

Let's build again here.
I think I get an error message about not knowing the type, etc.
It is recommended to commit and push once to the newly created branch around here.
It is hard to get backtracking from here.

ã“ã“ã§ã‚‚ã†ä¸€åº¦ãƒ“ãƒ«ãƒ‰ã—ã¦ã¿ã‚ˆã†ã€‚
å‹ãŒã‚ã‹ã‚‰ãªã„ãªã©ã®ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã¨æ€ã†ã€‚ \
ã“ã“ã‚‰è¾ºã§æ–°ã—ãä½œã£ãŸãƒ–ãƒ©ãƒ³ãƒã«ä¸€åº¦ã‚³ãƒŸãƒƒãƒˆã€pushã—ã¦ã¿ã¦ã¯?  \
ã“ã“ã‹ã‚‰å¾Œæˆ»ã‚ŠãŒå‡ºã‚‹ã¨å¤§å¤‰ã§ã™ã€‚

## Typescript conversion of linter-based libraries

linterç³»ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’è¿½åŠ ã™ã‚‹

```shell
yarn add --dev @typescript-eslint/eslint-plugin @typescript-eslint/parser
```

Change .eslintrc.js as follows.
It is important to note that the parser changes from babel to typescript-eslint.

.eslintrc.jsã‚’ä¸‹è¨˜ã®ã‚ˆã†ã«å¤‰æ›´ã€‚
å¤‰æ›´è¿½åŠ ãŒå¿…è¦ãªã‚‚ã®ã®ã¿æ›¸ã„ã¦ã„ã¾ã™ã€‚parserãŒbabelã‹ã‚‰typescript-eslintã«å¤‰ã‚ã‚‹ã®ã¯é‡è¦ã§ã™ã€‚

```js:eslintrc.js

  // parser: "babel-eslint",
  parser: "@typescript-eslint/parser",
  plugins: ["react", "@typescript-eslint"],
  rules: {
    "no-unused-vars": "off",
    "@typescript-eslint/no-unused-vars": "error",
  },
```

.babelrc.js should be removed.
It is not needed in typescript unless there is a specific reason.

.babelrc.jsã¯å‰Šé™¤ã—ã¦ãŠãã€‚
typescriptã§ã¯ç‰¹ã«ç†ç”±ãŒç„¡ã„é™ã‚Šä¸è¦ã€‚

You try building again.
If there are no errors in the library itself, you are good to go.
From this point on, we will make serious changes to the source code.
I recommend committing once around here.

ã‚‚ã†ä¸€åº¦ãƒ“ãƒ«ãƒ‰ã—ã¦ã¿ã¾ã™ã€‚
ãƒ©ã‚¤ãƒ–ãƒ©ãƒªè‡ªä½“ã®ã‚¨ãƒ©ãƒ¼ãŒå‡ºãªã„ãªã‚‰å¤§ä¸ˆå¤«ã§ã™ã€‚
ã“ã‚Œã‚ˆã‚Šã‚ã¨ã¯æœ¬æ ¼çš„ã«ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ã¾ã™ã€‚
ã“ã“ã‚‰è¾ºã§ä¸€åº¦ã‚³ãƒŸãƒƒãƒˆæ¨å¥¨ã€‚

## Change source code javasctip to typescript

ã“ã‚Œä»¥é™ã¯ä¸‹ã®ã‚ˆã†ã«è€ƒãˆãªãŒã‚‰ä¿®æ­£ã—ã¦ã„ãã¾ã™ã€‚js,tsã©ã¡ã‚‰ã®çŸ¥è­˜ã‚‚å¿…è¦ã§ã™ã€‚

- ãƒ“ãƒ«ãƒ‰æ™‚ã«ã©ã‚“ãªã‚¨ãƒ©ãƒ¼ãŒã§ã‚‹ã‹
- vscodeã«èµ¤æ–‡å­—ã§lintã¨ã—ã¦ä½•ãŒå•é¡Œã‹

From this point onward, we will modify it as we think below. knowledge of both js and ts is required.

### Error on makeStyles

There is a problem with the object in which the style definition is written.

ã‚¹ã‚¿ã‚¤ãƒ«ã®å®šç¾©ãŒæ›¸ã‹ã‚Œã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚

const useStyles = makeStyles(styles);

```js:components/Hello.js

const HelloStyle = {
    root: {
      flexGrow: 1,
      marginBottom: "20px",
    }
};

const useStyles = makeStyles(HelloStyle);

//
```

If you are specifying a style with an object like
*createStyles*.

ã¿ãŸã„ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§styleã‚’æŒ‡å®šã—ã¦ã„ã‚‹ãªã‚‰ã€
*createStyles*ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚

```ts:components/HelloStyle.ts
import { createStyles } from "@material-ui/core/styles";

const HelloStyle = createStyles({
    root: {
      flexGrow: 1,
      marginBottom: "20px",
    }
});

const useStyles = makeStyles(HelloStyle);

//
```

If you are using *theme*, you must explicitly state that it is a *Theme type* or you will get an error.

themeã‚’ä½¿ã£ã¦ã„ã‚‹å ´åˆã¯ã€*Themeå‹ã§ã‚ã‚‹*ã¨æ˜ç¤ºã—ãªã„ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚
typescriptã ã‹ã‚‰å½“ç„¶ã§ã™ã­

```ts:components/HelloStyle.ts
import { createStyles, Theme } from "@material-ui/core/styles";

const HelloStyle = (theme: Theme) =>
createStyles({
    root: {
    flexGrow: 1,
    marginBottom: "20px",
    }

    /// ... ã“ã‚Œä»¥é™ã«å¼•æ•°ã®themeã‚’ä½¿ã£ã¦ã„ã‚‹ã¨ã™ã‚‹ã€‚
});

const useStyles = makeStyles(HelloStyle);

// ...
```

#### Error caused by change to createStyles

##### fontWeight

If you change it to createStyles, you may get an error in the key.
For example, see below.

createStylesã¨å¤‰æ›´ã™ã‚‹ã¨ã‚­ãƒ¼ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚
ä¾‹ãˆã°ã€ä¸‹ã‚’ã¿ã¦ãã ã•ã„ã€‚

```ts:components/HelloStyle.ts
import { createStyles } from "@material-ui/core/styles";

const HelloStyle = createStyles({
    root: {
      flexGrow: 1,
      marginBottom: "20px",
      fontWeight: "500",
    }
});

const useStyles = makeStyles(HelloStyle);
```

Perhaps there is an error with fontWeight. 
Since it is typescript, string type is not allowed. So, I'm not sure if you are getting a
error occurred. If you simply took the "" and made it a NUMBER, it would not be an error.

I am writing styles in separate files for each class name, and I don't want to mess with the original files.
If you don't want to mess with the original file, you need to write the following.

If you don't know the scope of the effect of the change, you have to write it like this.

Translated with www.DeepL.com/Translator (free version)

æã‚‰ãã€fontWeightã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã¨æ€ã„ã¾ã™ã€‚ \
typescriptã«ã—ãŸã®ã§stringå‹ã¯è¨±ã•ã‚Œãªã„ã€‚ã¨ã„ã†ã“ã¨ãªã®ã§ã€ \
ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã®ã§ã™ã€‚å˜ç´”ã«""ã‚’ã¨ã£ã¦numberã«ã—ãŸã‚‰ã‚¨ãƒ©ãƒ¼ã§ãªããªã‚Šã¾ã™ã€‚

classåã”ã¨ã«åˆ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚¹ã‚¿ã‚¤ãƒ«ã‚’åˆ†ã‘ã¦æ›¸ã„ã¦ã„ã¦ã€ \
å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã„ã˜ã‚ŠãŸããªã„ãªã‚‰ä¸‹è¨˜ã®ã‚ˆã†ã«æ›¸ãå¿…è¦ãŒã‚ã‚‹ã€‚

å¤‰æ›´ã«ã‚ˆã‚‹å½±éŸ¿ç¯„å›²ãŒã‚ã‹ã‚‰ãªã„ãªã‚‰ã€ã“ã†æ›¸ãã—ã‹ç„¡ã„ã€‚

```ts:assets/HelloStyle.ts
import {
  title
} from "style/title";
import { createStyles } from "@material-ui/core/styles";
const HelloStyle = createStyles({
  // æœ¬æ¥ãªã‚‰ã‚¯ãƒ©ã‚¹åã‚’è¡¨ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹titleã‚’ãã®ã¾ã¾æ›¸ã„ãŸã‚‰ã„ã„ã ã‘
  // ã®ã¯ãšã ãŒã€fontWeightãŒstringå‹ã§å…¥ã£ã¦ã„ã‚‹ã®ã§ã€parseIntã«ã‚ˆã‚Šå¤‰æ›´ã™ã‚‹ã€‚
  // title,
  title: {
    ...title,
    fontWeight: parseInt(title.fontWeight),
  },
```

#### Property only accepts certain strings, but lint doesn't understand it

The as(cast) makes it explicit that it is a *specific string*.

as(ã‚­ãƒ£ã‚¹ãƒˆ) ã«ã‚ˆã‚Š*ç‰¹å®šã®æ–‡å­—åˆ—ã§ã‚ã‚‹*ã“ã¨ã‚’æ˜ç¤ºã™ã‚‹ã€‚

```ts:assets/HelloStyle.ts
import {
  title
} from "style/title";
import { createStyles } from "@material-ui/core/styles";
const HelloStyle = createStyles({
  // Normally, you would just write title, which is an object representing the class name, as it is However, since lint cannot determine whether position is a specific string or not, it casts the type explicitly.
  // æœ¬æ¥ãªã‚‰ã‚¯ãƒ©ã‚¹åã‚’è¡¨ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹titleã‚’ãã®ã¾ã¾æ›¸ã„ãŸã‚‰ã„ã„ã ã‘
  // ã®ã¯ãšã ãŒã€lintãŒpositionãŒç‰¹å®šã®æ–‡å­—åˆ—ã‹åˆ¤æ–­ã§ããªã„ãŸã‚ã€å‹ã‚’æ˜ç¤ºçš„ã«ã‚­ãƒ£ã‚¹ãƒˆã™ã‚‹ã€‚
  // title,
  title: {
    ...title,
    position: title.position as
      | "static"
      | "relative"
      | "absolute"
      | "sticky"
      | "fixed",
    fontWeight: parseInt(title.fontWeight),
  },
```

#### Error because the type of the props argument of the component function is not known

This can only be determined by taking a closer look at the source code OR 
You need to ask the person who wrote the source code to identify it.
Ask the person who wrote the code what he/she intended to do as much as possible.

You are supposed to define the argument types using interface. 
interface, it is recommended to refer to the types accepted by PropTypes as shown below.
If not, the programmer must determine the type from the source code.

Please refer to the following.

Translated with www.DeepL.com/Translator (free version)

ã“ã‚Œã¯ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’ã˜ã£ãã‚Šã¿ã‚‹ or \
æ›¸ã„ãŸäººã«èã‹ãªã„ã¨åˆ¤åˆ¥ã§ããªã„ã€‚ \
ã§ãã‚‹ã ã‘æ›¸ã„ãŸäººã«ä½•ã‚’æƒ³å®šã—ã¦ã„ãŸã‹èãã“ã¨ã€‚

interfaceã‚’ä½¿ã£ã¦å¼•æ•°ã®å‹ã‚’å®šç¾©ã—ã¦ã„ãã“ã¨ã«ãªã‚‹ãŒã€ \
interfaceã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ä¸‹è¨˜ã®ã‚ˆã†ã«PropTypesã§å—ã‘ä»˜ã‘ã‚‹å‹ã‚’å‚è€ƒã«ã™ã‚‹ã“ã¨ã¨ã‚ˆã„ã€‚ \
ãªã‘ã‚Œã°ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ãƒ—ãƒ­ã‚°ãƒ©ãƒãŒåˆ¤æ–­ã™ã‚‹ã—ã‹ãªã„ã€‚

ä¸‹è¨˜ã‚’å‚è€ƒã«ã—ã¦æ¬²ã—ã„ã€‚

```ts:assets/HelloStyle.ts
import PropTypes from "prop-types";

// PropTypesã‚’å‚è€ƒã«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å‹ã‚’è€ƒãˆã‚‹ã€‚
interface Props {
  active: number | number[];
  color?:
    | "warning"
    | "danger"
    | "success"
    | "info";
}

export default function HelloComponent(props: Props) {
// props
//
}

HelloComponent.propTypes = {
  // index of the default active collapse
  active: PropTypes.oneOfType([
    PropTypes.number,
    PropTypes.arrayOf(PropTypes.number),
  ]).isRequired,
  color: PropTypes.oneOf([
    "warning",
    "danger",
    "success",
    "info",
  ]),
};
```

#### Extend or composite of interface

Typescript can both extend and composite (in the form of having the interface in the interface's properties) the interface.

For example, which is better with a component called CustomButton? 
As it turns out, the one with fewer changes is better. Most of the time, composites change less and are more resistant to change.

Using extends can cause problems like the one below. 
Be aware that when such changes occur, the number of modifications will increase.

Translated with www.DeepL.com/Translator (free version)

typescriptã¯interfaceã®extendã‚‚ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆ(interfaceã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«interfaceã‚’æŒãŸã›ã‚‹ã¨ã„ã†å½¢ã§)ã‚‚ä¸¡æ–¹ã§ãã‚‹ã€‚ \

ä¾‹ãˆã°ã€CustomButtonã¨ã„ã†ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¨ã©ã¡ã‚‰ã®æ–¹ãŒã„ã„ã‹? \
çµè«–ã‹ã‚‰è¨€ã†ã¨å¤‰æ›´ãŒå°‘ãªã„æ–¹ãŒè‰¯ã„ã€‚å¤§æŠµã®å ´åˆã¯ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆã®æ–¹ãŒå¤‰æ›´ãŒå°‘ãªãã€å¤‰æ›´ã«å¼·ã„ã€‚

extendsã‚’ä½¿ã†ã¨ä¸‹ã®ã‚ˆã†ãªå•é¡ŒãŒèµ·ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚ \
ã“ã®ã‚ˆã†ãªå¤‰æ›´ãŒèµ·ãã‚‹ã¨ä¿®æ­£ç®‡æ‰€ãŒå¢—ãˆã‚‹ã®ã§æ°—ã‚’ã¤ã‘ã‚‹ã“ã¨ã€‚

```ts:components/HelloComponents.ts

import { Props as CustomButtonProps } from 'components/CustomButton'
import { Props as CustomDiverProps } from 'components/CustomDiver'

interface Props extends CustomButtonProps, CustomDiverProps {
  active: number | number[];
  
}

export default function HelloComponent(props: Props) {
// props
//
}
```

In this case, if CustomButtonProps and CustomDiverProps each have properties with the same name 
and the type is different, a type mismatch will result in an error.
A common case is when the inheriting Prop has a property with the common name "color".
In the above example, CustomButtonProps and CustomDiverProps both have a property named "Color", and if the type of the property is different from that of the inherited props, a Color mismatch error will occur.
In the above example, both CustomButtonProps and CustomDiverProps have a property named "Color", and if the types are different, it is necessary to align the type of Color.
Even if one has a normal type and the other has an optional type (color?:), an error will occur.

The recommended way to avoid this is compositing. I want you to see below.

ã“ã®ã¨ãã€CustomButtonProps, CustomDiverPropsãã‚Œãã‚Œã«åŒã˜åå‰ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒã‚ã‚Šã€ \
ãªãŠã‹ã¤å‹ãŒé•ã†å ´åˆã¯å‹ä¸ä¸€è‡´ã§ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã€‚ \
ã‚ˆãã‚ã‚‹ã®ãŒã€colorã¨ã„ã†ã‚ˆãã‚ã‚‹åå‰ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ç¶™æ‰¿å…ƒã®PropsãŒæŒã£ã¦ã„ã‚‹å ´åˆã€‚ \
ä¸Šã®ä¾‹ã ã¨CustomButtonProps, CustomDiverPropsã¨ã‚‚ã«Colorã¨ã„ã†ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã£ã¦ãŠã‚Šã€ \
ã‹ã¤å‹ãŒé•ã†å ´åˆã¯Colorã®å‹ã‚’æƒãˆã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€ä¿®æ­£ãŒã‚ã£ãŸå ´åˆã®å½±éŸ¿ç¯„å›²ãŒå¤§ãããªã‚‹ã€‚ \
ç‰‡ä¸€æ–¹ãŒæ™®é€šã®å‹ã§ã‚‚ã†ç‰‡ä¸€æ–¹ãŒã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«å‹(color?:)ã§ã‚‚ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã€‚

ã“ã‚Œã‚’é¿ã‘ã‚‹ãŸã‚ã«ãŠã™ã™ã‚ãªã®ãŒã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆã ã€‚ä¸‹ã‚’è¦‹ã¦æ¬²ã—ã„ã€‚

```ts

import { Props as CustomButtonProps } from 'components/CustomButton'
import { Props as CustomDiverProps } from 'components/CustomDiver'

interface Props {
  active: number | number[];
  CustomButtonProps: CustomButtonProps;
  CustomDiverProps: CustomDiverProps;
  
}

export default function HelloComponent(props: Props) {
// props
//
}
```

If you don't use only certain properties, like below You can also use type definition with type only for specific properties, as shown below.

ã‚‚ã—ã€ç‰¹å®šã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã ã‘ä½¿ã‚ãªã„ãªã‚‰ä¸‹ã®ã‚ˆã†ã«
ä¸‹ã®ã‚ˆã†ã«ç‰¹å®šã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã ã‘typeã§å‹å®šç¾©ã‚’ã™ã‚‹ã¨ã„ã†æ–¹æ³•ã‚‚ã‚ã‚‹ã€‚

```ts

import { Props as CustomButtonProps } from 'components/CustomButton'
import { Props as CustomDiverProps } from 'components/CustomDiver'

// interfaceã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å®šç¾©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯.(ãƒ‰ãƒƒãƒˆ)ã§ãªãã¦ã€["ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å"]ã¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
type CusomButtonPropsColor = CusomButtonProps["color"];
type CustomDiverPropsColor = CustomDiverProps["color"];

interface Props {
  active: number | number[];
  CustomButtonPropsColor: CusomButtonPropsColor;
  CustomDiverProps: CustomeDiverPropsColor;
  
}

export default function HelloComponent(props: Props) {
// props
//
}
```

#### rest parameter in props

In javascript, the following will take the object's key out of the variable and A new variable can be assigned.

javascriptã§ã¯ä¸‹è¨˜ã®ã‚ˆã†ã«ã™ã‚‹ã¨ã€å¤‰æ•°ã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚­ãƒ¼ã‚’å–ã‚Šå‡ºã—ã¦ã€ \
æ–°ãŸã«å¤‰æ•°ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```js
const point = {
  x: 34,
  y: 12,
  z: 100
};

const { 
  x,
  ...rest
  } = point;

// The value of REST is shown below.
// restã®å€¤ã¯ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã€‚
// rest = {
//   y: 12
//   z: 100
// }

```

In the above case, the variable x contains the value of key x in point, and all other keys go into rest. 
In react, this is used when you want to pass the properties of props to other components, as shown below. 
to other components, as shown below.

In this case, we need to add the *interface property to the rest parameter so that it can receive the key properly, as shown below.
Interface property with the *key assumed to be the rest parameter* so that it can receive the key in the rest parameter as shown below.

ä¸Šã®å ´åˆã¯å¤‰æ•°xã«pointã®ã‚­ãƒ¼xã®å€¤ãŒå…¥ã‚Šã€ãã‚Œä»¥å¤–ã®ã‚­ãƒ¼ã¯å…¨ã¦restã«å…¥ã‚‹ã€‚ \
reactã§ã©ã†ã„ã†ã¨ãã«ã“ã‚Œã‚’ä½¿ã†ã‹ã¨ã„ã†ã¨ã€ä¸‹ã®ã‚ˆã†ã«Propsã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ã•ã‚‰ã«ã€ \
ä»–ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«æ¸¡ã™æ™‚ã ã€‚

ã“ã®å ´åˆã¯ä¸‹ã®ã‚ˆã†ã«restãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã§ã¡ã‚ƒã‚“ã¨ã‚­ãƒ¼ã‚’å—ã‘ã‚Œã‚‹ã‚ˆã†ã«ã€ \
interfaceã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«*restãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦æƒ³å®šã—ã¦ã„ã‚‹ã‚­ãƒ¼*ã‚’æ›¸ãå¿…è¦ãŒã‚ã‚‹ã€‚

```ts
import Grid, { GridSize } from "@material-ui/core/Grid";

interface Props {
  x: number;
  color?:
    | "danger"
    | "success"
    | "info";
  xs?: GridSize;
}

export default function HelloComponent(props: Props) {

  const { 
    x,
    color,
    ...rest
    } = props;
  return (
    <Grid item {...rest} >
      {children}
    </Grid>
  );
// props
//
}
```

#### Props properties are object types, and their behavior is different depending on whether the key is present or not

Since javascript can easily add keys dynamically, the following code can also be written.

javascriptã¯å‹•çš„ã«ã‚­ãƒ¼ã‚’ç°¡å˜ã«è¿½åŠ ã§ãã‚‹ã®ã§ã€ä¸‹è¨˜ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚‚ã‹ã‘ã¾ã™ã€‚

```js

export default function HelloComponent(props) {
// props
//
}

// NAME is not a boolean value, nor is it necessarily a property to have in the first place.
// nameã¯çœŸå½å€¤ã§ã‚‚ãªã„ã—ã€ãã‚‚ãã‚‚ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ã—ã¦æŒã£ã¦ã„ã‚‹ã¨ã¯é™ã‚‰ãªã„ã€‚
if (props.name) {
  ...
  // Enter the process using the value of name.
}

```

Personally, I think it's best not to make use of such js specifications in the first place unless you have time to think it through carefully, otherwise it will become a breeding ground for bugs.
I think it's best not to do it unless you have time to think it through thoroughly, and usually you tend to create bugs that you don't understand.
ts will also cause errors depending on the type, so please *check* the existence of the property without being side-tracked as shown below.

å€‹äººçš„ã«ã¯ãã‚‚ãã‚‚ãã‚“ãªjsã®ä»•æ§˜ã‚’åˆ©ç”¨ã—ãŸä½œã‚Šã¯ä¸å¯§ã«ä½œã‚‰ãªã„ã¨ãƒã‚°ã®æ¸©åºŠã«ãªã‚‹ãŸã‚ã€ \
ã—ã£ã‹ã‚Šè€ƒãˆã‚‹æ™‚é–“ãŒãªã„é™ã‚Šã‚„ã‚ãŸæ–¹ãŒã„ã„ã¨æ€ã„ã¾ã™ã—ã€ãŸã„ã¦ã„ã‚ˆãã‚ã‹ã‚‰ãªã„ãƒã‚°ã‚’ä½œã‚ŠãŒã¡ã§ã™ã€‚ \
tsã§ã‚‚å‹ã«ã‚ˆã‚Šã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã®ã§ã€ä¸‹è¨˜ã®ã‚ˆã†ã«*æ¨ªç€ã›ãšãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å­˜åœ¨ã‚’ç¢ºèª*ã—ã¦ãã ã•ã„ã€‚

```ts:components/HelloComponents.ts

interface Props {
  name?: string
}

export default function HelloComponent(props: Props) {
// props
//
}

// If name exists and is not empty, it is processed.
// nameãŒå­˜åœ¨ã—ã¦ã€ç©ºæ–‡å­—ã§ãªã‘ã‚Œã°å‡¦ç†ã«å…¥ã‚‹ã€‚
if ("name" in props && props.name !== "") {
  ...
}
```

#### bracket notation

If you're not very familiar with javascript, you'll be amused. javascript can dynamically create objects using variables that may be undefined as shown below as keys. It is possible to create objects dynamically.

javascriptã«ã‚ã¾ã‚Šè©³ã—ããªã„äººã¯é¢é£Ÿã‚‰ã†ã¨æ€ã†ãŒã€ \
javascriptã¯ä¸‹ã®ã‚ˆã†ã«undefinedã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°ã‚’ã‚­ãƒ¼ã« \
å‹•çš„ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```js:bracket_example.js

// The name key may be undefined, but it is not an error.
// name keyãŒundefinedã‹ã‚‚ã—ã‚Œãªã„ãŒã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã„ã€‚
const helloObject = {
  x: 30,
  [name]: false

}
```

I think the programmer's intention is to assume that if name is undefined, then the name key itself does not exist or is false.
However, this is not allowed in most programming languages because it is a breeding ground for bugs. typescript does not allow it either. Therefore, the above syntax would result in a *syntax error* in typescript.

If you want to write it this way, you need to make sure that name is not undefined as shown below.

ãƒ—ãƒ­ã‚°ãƒ©ãƒã®æ„å›³ã¨ã—ã¦ã¯ã€nameãŒundefinedãªã‚‰nameã‚­ãƒ¼è‡ªä½“å­˜åœ¨ã—ãªã„ã€ã¾ãŸã¯falseã¨ãªã‚‹ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã‚‹ã¨æ€ã†ã€‚ \
ã—ã‹ã—ã€ã“ã‚Œã¯ãƒã‚°ã®æ¸©åºŠã«ãªã‚‹ã›ã„ã‹å¤§æŠµã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã¯è¨±ã•ã‚Œã¦ãŠã‚‰ãšã€ \
typescriptã§ã‚‚å½“ç„¶è¨±ã•ã‚Œã¦ã„ãªã„ã€‚ãã®ãŸã‚ä¸Šã®æ›¸ãæ–¹ã‚’ã™ã‚‹ã¨*typescriptã§ã¯æ§‹æ–‡ã‚¨ãƒ©ãƒ¼*ã«ãªã‚‹ã€‚

ã“ã®æ›¸ãæ–¹ã‚’ã—ãŸã„å ´åˆnameãŒä¸‹è¨˜ã®ã‚ˆã†ã«undefinedã§ãªã„ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚

```ts:bracket_example.ts

// When adding properties to an object later in typescript, it is necessary to declare the object's type as shown below.
// typescriptã§å¾Œã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ ã™ã‚‹ã¨ãã«ã¯ä¸‹ã®ã‚ˆã†ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’å®£è¨€ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
const helloObject:{ [key: string]: boolean | number } = {
  x: 30
}

if ( name !== undefined ) {
  // Since the condition for entering an if statement is that it is not undefined, it is guaranteed not to be undefined.
  // ifæ–‡ã«å…¥ã‚‹æ¡ä»¶ãŒundefinedã§ãªã„ã“ã¨ã§ã‚ã‚‹ãŸã‚ã€undefinedã§ãªã„ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚‹ã€‚
  helloObject[name] = false;
}

const HelloClasses = classNames(cardClassesShape);
```

When to use this, for example, whether to take a class name as an argument in react as shown below.
This is useful when you don't know if the argument will be passed.

ã“ã‚Œã‚’ã©ã®ã‚ˆã†ãªæ™‚ã«ä½¿ã†ã‹ã¨ã„ã†ã¨ä¾‹ãˆã°ä¸‹ã®ã‚ˆã†ã«reactã§classåã‚’å¼•æ•°ã«ã¨ã‚‹ã‹ã©ã†ã‹ã€‚ \
å¼•æ•°ãŒæ¸¡ã•ã‚Œã‚‹ã‹ã‚ã‹ã‚‰ãªã„æ™‚ã«å½¹ã«ç«‹ã¤ã€‚

```ts:bracket_example.ts

const classes = useStyles();

const helloClassesShape: { [key: string]: boolean } = {};

if (color !== undefined) {
  helloClassesShape[classes[color]] = true;
}

const helloClasses = classNames(helloClassesShape);
```

### useState is null

```js:components/HelloCompotents.js
const [element, setElement] = React.useState(null);
```

If null or undefined is used, it will be type any, and IntelliSense will not work.
There should be a specific type to use.
Use a generic to specify the type as shown below.

nullã‚„undefinedã‚’ä½¿ã†ã¨anyå‹ã«ãªã£ã¦ã—ã¾ã†ãŸã‚ã€ã‚¤ãƒ³ãƒ†ãƒªã‚»ãƒ³ã‚¹ãŒåŠ¹ã‹ãªããªã‚Šã¾ã™ã€‚ \
ä½¿ã†å‹ã¯æ±ºã¾ã£ã¦ã„ã‚‹ã¯ãšãªã®ã§ã€ \
ä¸‹è¨˜ã®ã‚ˆã†ã«ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚’ä½¿ã£ã¦å‹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚

```ts:components/HelloCompotents.ts
const [element, setElement] = React.useState<HTMLElement | null>(null);
```

Value types such as string and number can be initialized like in golang, when initializing useState.
It is also a good idea to initialize them with an empty string and 0, respectively.

stringå‹ã‚„ã€numberå‹ãªã©ã®å€¤å‹ã¯golangã¿ãŸãã€useStateã®åˆæœŸåŒ–æ™‚ã« \
ãã‚Œãã‚Œç©ºæ–‡å­—åˆ—,0ã§åˆæœŸåŒ–ã™ã‚‹ã®ã‚‚ã„ã„ã¨æ€ã„ã¾ã™ã€‚

```ts:components/HelloCompotents.ts

// Because the type is implicitly determined, completion becomes more effective.
// æš—é»™çš„ã«å‹ãŒæ±ºã¾ã‚‹ãŸã‚ã€è£œå®ŒãŒåŠ¹ãã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
const [cnt, setCnt] = React.useState(0);
const [message, setMes] = React.useState('');
```
