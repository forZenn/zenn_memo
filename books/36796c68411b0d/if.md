---
title: "条件文、真偽値の扱い、ベターな手法"
---

## 値の比較


**if文で比較するときは定数や値を常に左**に置くように心がけてください。

例えば、以下の書き方ではなく、

```Powershell
Set-Variable -Name $val -Value 5 -Scope -Option Constant

if ($val -eq 5) {
    Write-Host ""
}
```

次のように定数を左側に書いてください。

```powershell
Set-Variable -Name $val -Value 5 -Scope -Option Constant

if (5 -eq $val) {
    Write-Host "Better Powershell code."
}
```

これについてはvscodeのlinterにもそのような指示が出丸。

これはよくプログラミング言語では定数を左に書くと
比較時に==と=を間違えて姉妹、比較のつもりが、変数の代入をおこなってしまうというのがあります。
なのでそれを避けたい理由と思われがちですが、
Powershellには他にも理由があります。

それは**Powershellは右辺が配列かどうかでオペレーターの挙動が変わる**
という性質を持っているからです。

下記の例を見てください。

```powershell

# $trueが帰る。
4 -eq 4

# $falseが帰る
5 -eq 4

# 4が返る。
@(5, 4, 3) -eq 4
```

**左辺が配列の場合は-eq, -gt, -gtなどは右辺の条件を満たす、左辺の配列に入っている要素を返す**という
オペレーターに変わります。

よって以上、未満などは次のようになります。

```powershell
# 4, 5が帰る。
@(1, 4, 5) -ge 4


# 11 が帰る。
@(11, 13, 34) -lt 13 
```

次の動作は面食らいます。

```powershell
# 真偽値としてfalseである0が帰ってくるため、ループに入らない。
if (@(5, 0, 3) -eq 0){
    Write-Host "Is bug?"
}


# 真偽値として$tureである1が返ってくるため、ループに入る。
if (@(5, 1, 3) -eq 1){
    Write-Host "Is bug?"
}


```

Powershellは構造上、どうしても配列か普通の変数か曖昧な変数が出やすいため、
無意識のうちに配列が混ざりやすく、デフォルトでこのような仕様になっているのは私は正直設計ミスだと思います。
配列で比較したいならそれ専用のオペレーター作ればいいし。

が、そんなこと言ってられないのでプログラマーはそれに合わせましょう。


## 配列処理

Powershellは配列を+を使ってappendできます。

```powershell

# @(1,2,3,4,5,6)という配列が作成される。
@(1, 2, 3) + @(4, 5, 6)
```

正直あまり使わない機能です。

